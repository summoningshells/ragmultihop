# Blueprint - SystÃ¨me RAG Hybride GreenPower Solutions

Groupe 2- Fabien G, Dorian, Paul, Noha, Sacha

## ğŸ“‹ Vue d'ensemble du projet

SystÃ¨me de **Retrieval-Augmented Generation (RAG) Hybride** qui combine deux approches complÃ©mentaires pour rÃ©pondre intelligemment aux questions sur les produits et Ã©vÃ©nements de GreenPower Solutions :

- **Recherche vectorielle** (Qdrant) pour les questions descriptives simples
- **Graphe de connaissances** (Neo4j) pour les questions relationnelles complexes nÃ©cessitant du multi-hop reasoning

### ğŸ¯ Objectif

Permettre de poser des questions en langage naturel sur :
- Les produits solaires autonomes GreenPower
- Les Ã©vÃ©nements (salons, festivals alimentÃ©s)
- Les ventes et dÃ©ploiements
- Les projets R&D
- Les relations entre ces entitÃ©s

### ğŸ—ï¸ Architecture Globale

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      INTERFACE UTILISATEUR                            â”‚
â”‚                     (app_hybrid.py - Streamlit)                       â”‚
â”‚                                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚   RAG    â”‚  â”‚   RAG    â”‚  â”‚ Routeur  â”‚  â”‚  Dashboard   â”‚        â”‚
â”‚  â”‚  Simple  â”‚  â”‚ Hybride  â”‚  â”‚  Intel.  â”‚  â”‚  MÃ©triques   â”‚        â”‚
â”‚  â”‚ (Qdrant) â”‚  â”‚  Q+Neo4j â”‚  â”‚  (Auto)  â”‚  â”‚ (dashboard.py)â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COUCHE DE ROUTAGE                         â”‚
â”‚                   (hybrid_rag.py)                            â”‚
â”‚                                                               â”‚
â”‚  classify_question() â†’ dÃ©termine la stratÃ©gie optimale       â”‚
â”‚     â”œâ”€â”€ Keywords multi-hop â†’ RAG Hybride                     â”‚
â”‚     â””â”€â”€ Keywords simples â†’ RAG Simple                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼                                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  QDRANT          â”‚                    â”‚  NEO4J           â”‚
â”‚  (Vectoriel)     â”‚                    â”‚  (Graphe)        â”‚
â”‚                  â”‚                    â”‚                  â”‚
â”‚ â€¢ Embeddings     â”‚                    â”‚ â€¢ NÅ“uds:         â”‚
â”‚ â€¢ SimilaritÃ©     â”‚                    â”‚   - Product      â”‚
â”‚   sÃ©mantique     â”‚                    â”‚   - Event        â”‚
â”‚ â€¢ Documents      â”‚                    â”‚   - TradeShow    â”‚
â”‚                  â”‚                    â”‚   - Sale         â”‚
â”‚                  â”‚                    â”‚   - RDProject    â”‚
â”‚                  â”‚                    â”‚   - BatteryType  â”‚
â”‚                  â”‚                    â”‚                  â”‚
â”‚                  â”‚                    â”‚ â€¢ Relations:     â”‚
â”‚                  â”‚                    â”‚   - DEPLOYED_AT  â”‚
â”‚                  â”‚                    â”‚   - SOLD_AT      â”‚
â”‚                  â”‚                    â”‚   - USES_BATTERY â”‚
â”‚                  â”‚                    â”‚   - etc.         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                                         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     MISTRAL AI LLM                           â”‚
â”‚  â€¢ GÃ©nÃ©ration de rÃ©ponses contextualisÃ©es                    â”‚
â”‚  â€¢ Embeddings (mistral-embed)                                â”‚
â”‚  â€¢ Chat (mistral-small-latest)                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ Modules et FonctionnalitÃ©s

### 1. **hybrid_rag.py** - Routeur Intelligent et Orchestrateur

**RÃ´le principal**: Classifier les questions et orchestrer la stratÃ©gie de rÃ©ponse appropriÃ©e.

#### Classe `HybridRAG`

**FonctionnalitÃ©s principales**:

- **`classify_question(question)`**
  - Analyse la question pour dÃ©terminer la complexitÃ©
  - DÃ©tecte les mots-clÃ©s multi-hop (relations, agrÃ©gations, Ã©vÃ©nements)
  - DÃ©tecte les mots-clÃ©s simples (descriptions, spÃ©cifications)
  - Retourne: `"simple"` ou `"multi_hop"`

- **`query_simple(question, vector_store)`**
  - RAG classique avec Qdrant uniquement
  - Recherche par similaritÃ© sÃ©mantique (top 3 documents)
  - GÃ©nÃ¨re une rÃ©ponse avec le LLM Mistral
  - Cas d'usage: "Qu'est-ce que le produit GreenPower Max?"

- **`query_hybrid(question, vector_store)`**
  - RAG hybride combinant Qdrant + Neo4j
  - RÃ©cupÃ¨re le contexte vectoriel (Qdrant)
  - RÃ©cupÃ¨re le contexte relationnel (Neo4j)
  - Fusionne les deux contextes dans un prompt enrichi
  - Cas d'usage: "Quels Ã©vÃ©nements ont utilisÃ© des produits vendus Ã  Pollutec Paris?"

- **`query(question, vector_store, force_strategy=None)`**
  - Point d'entrÃ©e principal avec routage automatique
  - Permet de forcer une stratÃ©gie si nÃ©cessaire
  - Retourne: `{answer, sources, strategy}`

- **`explain_routing(question)`**
  - Explique pourquoi une stratÃ©gie a Ã©tÃ© choisie
  - Utile pour la transparence et le debugging

**Exemples de questions traitÃ©es**:
- Simple: "Quel est le prix du GreenPower Max?"
- Multi-hop: "Quels projets R&D visent les produits utilisÃ©s aux festivals?"
- Multi-hop: "Quel est le CO2 total Ã©conomisÃ© par PG-M01?"

---

### 2. **neo4j_query.py** - RequÃªtes Multi-Hop sur le Graphe

**RÃ´le principal**: ExÃ©cuter des requÃªtes Cypher complexes pour extraire des informations relationnelles.

#### Classe `Neo4jQuerier`

**RequÃªtes multi-hop complexes**:

- **`query_events_with_products_sold_at_tradeshows(location=None)`**
  - Chemin: `Product â†’ DEPLOYED_AT â†’ Event` + `Product â† INCLUDES_PRODUCT â† Sale â†’ SOLD_AT â†’ TradeShow`
  - Question: "Quels Ã©vÃ©nements ont utilisÃ© des produits vendus Ã  Pollutec Paris?"
  - Multi-hop: 2 sauts dans le graphe

- **`query_total_co2_saved_by_product(product_id)`**
  - Chemin: `Product â†’ DEPLOYED_AT â†’ Event` (avec agrÃ©gation CO2)
  - Question: "Quel est le CO2 total Ã©conomisÃ© par tous les dÃ©ploiements de PG-M01?"
  - AgrÃ©gation: Somme des rÃ©ductions CO2 sur tous les Ã©vÃ©nements

- **`query_tradeshows_sales_by_customer_type(customer_type)`**
  - Chemin: `TradeShow â† SOLD_AT â† Sale` (filtrÃ© par type client)
  - Question: "Quels salons ont gÃ©nÃ©rÃ© le plus de revenus avec les collectivitÃ©s?"
  - AgrÃ©gation: Somme des revenus par salon

- **`query_rd_projects_for_festival_products()`**
  - Chemin: `Event â† DEPLOYED_AT â† Product â† TARGETS_PRODUCT â† RDProject`
  - Question: "Quels projets R&D visent les produits utilisÃ©s aux festivals?"
  - Multi-hop: 3 sauts + filtrage par type d'Ã©vÃ©nement

**RequÃªtes simples**:

- **`query_products_by_battery_type(battery_type)`**
  - Recherche produits par type de batterie (LiFePO4, Tesla)

- **`query_top_revenue_tradeshows(limit=5)`**
  - Top salons par revenu gÃ©nÃ©rÃ©

- **`query_product_sales_across_tradeshows(product_id)`**
  - Historique des ventes d'un produit sur tous les salons

**Fonctions utilitaires**:

- **`get_graph_context_for_question(question)`**
  - Analyse la question et exÃ©cute automatiquement les requÃªtes pertinentes
  - DÃ©tecte patterns: Ã©vÃ©nements, CO2, collectivitÃ©s, R&D, batteries, etc.
  - Retourne une liste de rÃ©sultats structurÃ©s

- **`format_graph_context(context)`**
  - Formate les rÃ©sultats du graphe en texte lisible pour le LLM
  - Convertit les rÃ©sultats Neo4j en contexte textuel

---

### 3. **neo4j_loader.py** - Chargement des DonnÃ©es dans le Graphe

**RÃ´le principal**: Parser les fichiers JSON et crÃ©er le graphe Neo4j complet avec toutes les relations.

#### Classe `Neo4jLoader`

**FonctionnalitÃ©s**:

- **`clear_database()`**
  - Nettoie toutes les donnÃ©es du graphe
  - UtilisÃ© avant un rechargement complet

- **`create_indexes()`**
  - CrÃ©e les index sur les IDs pour optimiser les performances
  - Index sur: product_id, event_id, trade_show_id, rd_project_id, customer_type

- **`load_products(products_file)`**
  - Parse `greenpower_products_enriched.json`
  - CrÃ©e les nÅ“uds `Product` avec toutes leurs propriÃ©tÃ©s:
    - SpÃ©cifications techniques (puissance, batterie, solaire)
    - Prix et marges
    - RÃ©duction CO2
  - CrÃ©e les nÅ“uds `BatteryType` et les relations `USES_BATTERY`

- **`load_events(events_file)`**
  - Parse `greenpower_events_enriched.json`
  - CrÃ©e deux types d'Ã©vÃ©nements:
    1. **TradeShows** (salons/expositions):
       - NÅ“uds `TradeShow` avec leads et revenus
       - Relations `DISPLAYED_AT` (produits affichÃ©s)
       - CrÃ©e des nÅ“uds `Sale` par type de client (particuliers, entreprises, collectivitÃ©s)
       - Relations `SOLD_AT` (ventes â†’ salon)
       - Relations `INCLUDES_PRODUCT` avec quantitÃ©s (ex: "PG-M01 x3")

    2. **Powered Events** (Ã©vÃ©nements alimentÃ©s):
       - NÅ“uds `Event` (festivals, concerts)
       - Relations `DEPLOYED_AT` avec quantitÃ©s de produits dÃ©ployÃ©s
       - PropriÃ©tÃ©s: attendees, runtime, fuel_saved, co2_reduction

- **`load_rd_projects(rd_file)`**
  - Parse `greenpower_rd_innovations.json`
  - CrÃ©e les nÅ“uds `RDProject` avec:
    - Status (Active, Testing, Deployed)
    - Objectif
    - Ã‰conomies projetÃ©es
  - Relations `TARGETS_PRODUCT` vers les produits ciblÃ©s

- **`load_all()`**
  - Charge toutes les donnÃ©es en une seule commande
  - SÃ©quence: clear â†’ indexes â†’ products â†’ events â†’ rd_projects

- **`verify_data()`**
  - Affiche les statistiques du graphe (nombre de nÅ“uds et relations)
  - Utile pour vÃ©rifier que tout a Ã©tÃ© chargÃ© correctement

**ModÃ¨le de donnÃ©es crÃ©Ã©**:
- 66 nÅ“uds au total
- 149 relations
- 6 types de nÅ“uds: Product, Event, TradeShow, Sale, RDProject, BatteryType

---

### 4. **app_hybrid.py** - Interface Utilisateur Streamlit

**RÃ´le principal**: Interface web interactive pour interagir avec le systÃ¨me RAG hybride.

#### FonctionnalitÃ©s de l'application

**Architecture Streamlit**:

- **`init_components()`** (cached)
  - Initialise Qdrant client
  - Initialise Mistral embeddings
  - Initialise Mistral LLM
  - Initialise HybridRAG
  - Mise en cache pour Ã©viter rÃ©initialisations

- **`load_and_index_documents()`** (cached)
  - Charge tous les documents depuis `data/`
  - Supporte: .txt, .json, .csv, .pdf
  - DÃ©coupe en chunks (1000 chars, overlap 200)
  - CrÃ©e/charge la collection Qdrant
  - Mise en cache: instant aprÃ¨s le premier chargement

**3 Onglets principaux**:

1. **RAG Classique (Qdrant)**
   - Utilise uniquement la recherche vectorielle
   - Affiche la rÃ©ponse + sources Qdrant
   - IdÃ©al pour: descriptions, spÃ©cifications, prix

2. **RAG+Graph Multi-Hop**
   - Force l'utilisation de Qdrant + Neo4j
   - Affiche la rÃ©ponse + sources des deux bases
   - Vue sÃ©parÃ©e des sources vectorielles et graphe
   - IdÃ©al pour: relations, agrÃ©gations, multi-hop

3. **Routeur Intelligent (Auto)**
   - Mode recommandÃ©
   - Classification automatique de la question
   - Explique la dÃ©cision du routeur
   - Badge visuel de la stratÃ©gie choisie
   - Sources adaptÃ©es Ã  la stratÃ©gie

**Sidebar**:
- Bouton "ğŸ”„ Recharger" : rÃ©initialise le cache Streamlit
- Bouton "ğŸ—‘ï¸ RÃ©initialiser" : supprime la collection Qdrant
- Bouton "ğŸ“Š Charger Neo4j" : lance le chargement du graphe
- Exemples de questions simples et multi-hop

**Loaders de documents**:
- `load_txt()`: Fichiers texte
- `load_json()`: Fichiers JSON (formatÃ©s pour embedding)
- `load_csv()`: CSV (chaque ligne = 1 document)
- `load_pdf()`: PDF (chaque page = 1 document)

---

### 5. **init_system.py** - Script d'Initialisation

**RÃ´le principal**: VÃ©rifier et initialiser tous les composants du systÃ¨me.

#### FonctionnalitÃ©s

- **`check_env()`**
  - VÃ©rifie la prÃ©sence de toutes les variables d'environnement requises
  - Masque les secrets dans l'affichage
  - Variables vÃ©rifiÃ©es: MISTRAL_API_KEY, QDRANT_*, NEO4J_*

- **`check_neo4j_connection()`**
  - Teste la connexion Ã  Neo4j
  - ExÃ©cute une requÃªte simple pour valider

- **`check_qdrant_connection()`**
  - Teste la connexion Ã  Qdrant
  - Liste les collections disponibles

- **`load_neo4j_data()`**
  - VÃ©rifie si des donnÃ©es existent dÃ©jÃ 
  - Demande confirmation avant rechargement
  - Lance le chargement complet si nÃ©cessaire

- **`show_summary()`**
  - Affiche le rÃ©sumÃ© de l'initialisation
  - Commandes utiles
  - Conseils d'utilisation

**Workflow**:
1. VÃ©rification des variables d'environnement
2. Test connexion Neo4j
3. Test connexion Qdrant
4. Chargement des donnÃ©es Neo4j (si nÃ©cessaire)
5. Affichage du rÃ©sumÃ©

---

### 6. **dashboard.py** - Dashboard de MÃ©triques et Performance

**RÃ´le principal**: Collecter et afficher les mÃ©triques de performance en temps rÃ©el de Qdrant et Neo4j avec des visualisations graphiques.

#### Classe `DashboardMetrics`

**FonctionnalitÃ©s principales**:

- **`get_qdrant_metrics()`**
  - RÃ©cupÃ¨re les statistiques de la base vectorielle Qdrant
  - Retourne: nombre de collections, documents indexÃ©s, vecteurs, dimension vectorielle
  - DÃ©tecte si la collection principale existe
  - Gestion d'erreur avec affichage des messages

- **`get_neo4j_metrics()`**
  - RÃ©cupÃ¨re les statistiques du graphe Neo4j
  - Compte les nÅ“uds par type (Product, Event, TradeShow, Sale, RDProject, BatteryType)
  - Compte les relations par type (DEPLOYED_AT, SOLD_AT, USES_BATTERY, etc.)
  - Retourne: total des nÅ“uds, total des relations, distributions par type
  - RequÃªtes Cypher optimisÃ©es avec agrÃ©gations

- **`measure_qdrant_search_time(question, k=3)`**
  - Mesure le temps de recherche vectorielle Qdrant
  - ParamÃ¨tres: question de test, nombre de rÃ©sultats (k)
  - Retourne: temps en millisecondes, nombre de rÃ©sultats trouvÃ©s
  - Utile pour benchmarking et optimisation

- **`measure_neo4j_query_time(query_func, *args)`**
  - Mesure le temps d'exÃ©cution d'une requÃªte Neo4j
  - Accepte n'importe quelle fonction de requÃªte Neo4j
  - Retourne: temps en millisecondes, nombre de rÃ©sultats
  - Permet de comparer les performances de diffÃ©rentes requÃªtes

#### Fonction `render_dashboard(qdrant_client, neo4j_querier, vector_store)`

**Interface utilisateur du dashboard** (intÃ©grÃ©e comme onglet dans app_hybrid.py):

**Section 1 - MÃ©triques Qdrant** :
- Affichage des mÃ©triques en temps rÃ©el :
  - Nombre de collections
  - Documents indexÃ©s
  - Vecteurs stockÃ©s
  - Dimension vectorielle
- **Test de performance de recherche** :
  - Bouton "Lancer test Qdrant"
  - Teste 3 questions types
  - Affiche tableau des temps de rÃ©ponse
  - Graphique en barres des temps par question
  - Calcul et affichage du temps moyen

**Section 2 - MÃ©triques Neo4j** :
- Affichage des mÃ©triques du graphe :
  - Total de nÅ“uds
  - Total de relations
- **Graphiques de distribution** :
  - Graphique 1 : Distribution des nÅ“uds par type (bar chart)
  - Graphique 2 : Distribution des relations par type (bar chart)
- **Test de performance des requÃªtes** :
  - Bouton "Lancer test Neo4j"
  - Teste 4 types de requÃªtes :
    1. RequÃªte simple (top salons)
    2. RequÃªte multi-hop (Ã©vÃ©nements avec produits vendus)
    3. AgrÃ©gation (ventes par type client)
    4. Multi-hop complexe (R&D festivals, 3 sauts)
  - Affiche tableau comparatif
  - Graphique en barres des temps par requÃªte
  - Calcul du temps moyen

**Section 3 - Comparaison RAG Simple vs Hybride** :
- Input pour question de test personnalisÃ©e
- Bouton "Comparer"
- **Comparaison cÃ´te Ã  cÃ´te** :
  - RAG Simple (Qdrant uniquement) : temps, nombre de sources
  - RAG Hybride (Qdrant + Neo4j) : temps, nombre de sources combinÃ©es
- Graphique comparatif des temps
- Analyse du diffÃ©rentiel de performance en pourcentage
- Recommandations basÃ©es sur les rÃ©sultats

**Section 4 - Ã‰tat du SystÃ¨me** :
- Indicateurs de statut :
  - ğŸŸ¢ Qdrant : OpÃ©rationnel / ğŸ”´ Erreur
  - ğŸŸ¢ Neo4j : OpÃ©rationnel / ğŸ”´ Erreur
  - ğŸŸ¢ Global : SystÃ¨me OK / ğŸ”´ ProblÃ¨me dÃ©tectÃ©
- Timestamp de derniÃ¨re mise Ã  jour
- **Auto-refresh** : Option pour rafraÃ®chir automatiquement toutes les 5 secondes

**CaractÃ©ristiques techniques** :
- Utilise uniquement Streamlit natif (pas de bibliothÃ¨ques externes lourdes)
- Graphiques avec `st.bar_chart()` et `st.metric()`
- Dataframes pandas pour tableaux de donnÃ©es
- Gestion d'erreurs robuste avec messages utilisateur
- Performance mesurÃ©e en millisecondes (prÃ©cision 2 dÃ©cimales)
- Design responsive avec colonnes Streamlit

**Cas d'usage** :
1. **Monitoring** : Surveiller l'Ã©tat du systÃ¨me en temps rÃ©el
2. **Debugging** : Identifier les requÃªtes lentes
3. **Optimisation** : Comparer les performances des stratÃ©gies RAG
4. **DÃ©mo** : Montrer les capacitÃ©s du systÃ¨me aux stakeholders
5. **Benchmarking** : Mesurer l'impact des changements d'infrastructure

---

## ğŸ”„ Flux de DonnÃ©es

### Flux Question â†’ RÃ©ponse (RAG Simple)

```
1. Utilisateur pose une question: "Quel est le prix du GreenPower Max?"
   â†“
2. HybridRAG.classify_question() â†’ "simple"
   â†“
3. HybridRAG.query_simple()
   â†“
4. Recherche vectorielle Qdrant (top 3 documents)
   â†“
5. Contexte envoyÃ© au LLM Mistral
   â†“
6. GÃ©nÃ©ration de la rÃ©ponse
   â†“
7. Retour: {answer, sources: {vector_docs}, strategy: "simple"}
```

### Flux Question â†’ RÃ©ponse (RAG Hybride)

```
1. Utilisateur pose: "Quels Ã©vÃ©nements ont utilisÃ© des produits vendus Ã  Paris?"
   â†“
2. HybridRAG.classify_question() â†’ "multi_hop"
   â†“
3. HybridRAG.query_hybrid()
   â†“
4. ParallÃ¨lement:
   â”œâ”€> Qdrant: recherche vectorielle (top 3 docs)
   â””â”€> Neo4j: get_graph_context_for_question()
       â””â”€> DÃ©tecte: "Ã©vÃ©nements" + "vendus" + "paris"
       â””â”€> ExÃ©cute: query_events_with_products_sold_at_tradeshows("Paris")
   â†“
5. Fusion des deux contextes dans un prompt enrichi
   â†“
6. LLM Mistral gÃ©nÃ¨re rÃ©ponse basÃ©e sur les deux sources
   â†“
7. Retour: {answer, sources: {vector_docs, graph_context}, strategy: "hybrid"}
```

---

## ğŸ’¾ ModÃ¨le de DonnÃ©es Neo4j

### NÅ“uds

```
(Product)
â”œâ”€ product_id
â”œâ”€ name
â”œâ”€ category
â”œâ”€ continuous_power
â”œâ”€ peak_power
â”œâ”€ battery_capacity
â”œâ”€ battery_type
â”œâ”€ solar_capacity
â”œâ”€ total_cost
â”œâ”€ avg_selling_price
â”œâ”€ margin_percentage
â”œâ”€ co2_reduction
â””â”€ rental_available

(Event)
â”œâ”€ event_id
â”œâ”€ name
â”œâ”€ type (festival, concert, etc.)
â”œâ”€ location
â”œâ”€ date
â”œâ”€ attendees
â”œâ”€ runtime
â”œâ”€ fuel_saved
â””â”€ co2_reduction

(TradeShow)
â”œâ”€ event_id
â”œâ”€ name
â”œâ”€ type
â”œâ”€ location
â”œâ”€ date
â”œâ”€ leads_generated
â””â”€ total_sales

(Sale)
â”œâ”€ sale_id
â”œâ”€ customer_type (particuliers, entreprises, collectivites)
â”œâ”€ units
â””â”€ total_revenue

(RDProject)
â”œâ”€ project_id
â”œâ”€ name
â”œâ”€ status
â”œâ”€ objective
â””â”€ projected_savings

(BatteryType)
â””â”€ type (LiFePO4, Tesla, etc.)
```

### Relations

```
(Product)-[:DEPLOYED_AT {quantity}]->(Event)
(Product)-[:DISPLAYED_AT]->(TradeShow)
(Product)-[:USES_BATTERY]->(BatteryType)

(Sale)-[:SOLD_AT]->(TradeShow)
(Sale)-[:INCLUDES_PRODUCT {quantity}]->(Product)

(RDProject)-[:TARGETS_PRODUCT]->(Product)
```

---

## ğŸ¯ Cas d'Usage Typiques

### 1. Questions Simples (RAG Vectoriel)

**Question**: "Qu'est-ce que le GreenPower Max?"
- **StratÃ©gie**: RAG Simple
- **Source**: Qdrant uniquement
- **Pourquoi**: Question descriptive, pas de relations

**Question**: "Quels sont les produits avec batteries LiFePO4?"
- **StratÃ©gie**: RAG Hybride
- **Source**: Neo4j (query_products_by_battery_type)
- **Pourquoi**: RequÃªte structurÃ©e simple sur le graphe

### 2. Questions Multi-Hop (RAG Hybride)

**Question**: "Quels Ã©vÃ©nements ont utilisÃ© des produits vendus Ã  Pollutec Paris?"
- **StratÃ©gie**: RAG Hybride
- **Chemin**: Product â†’ DEPLOYED_AT â†’ Event + Product â† INCLUDES_PRODUCT â† Sale â†’ SOLD_AT â†’ TradeShow
- **RequÃªte**: query_events_with_products_sold_at_tradeshows("Paris")
- **ComplexitÃ©**: 2-3 sauts dans le graphe

**Question**: "Quels projets R&D visent les produits utilisÃ©s aux festivals?"
- **StratÃ©gie**: RAG Hybride
- **Chemin**: RDProject â†’ TARGETS_PRODUCT â†’ Product â†’ DEPLOYED_AT â†’ Event (type=festival)
- **RequÃªte**: query_rd_projects_for_festival_products()
- **ComplexitÃ©**: 3 sauts + filtrage

### 3. AgrÃ©gations Complexes

**Question**: "Quel est le CO2 total Ã©conomisÃ© par le produit PG-M01?"
- **StratÃ©gie**: RAG Hybride
- **OpÃ©ration**: Somme de tous les dÃ©ploiements
- **RequÃªte**: query_total_co2_saved_by_product("PG-M01")
- **Type**: AgrÃ©gation avec calcul

**Question**: "Quels salons ont gÃ©nÃ©rÃ© le plus de revenus avec les collectivitÃ©s?"
- **StratÃ©gie**: RAG Hybride
- **OpÃ©ration**: Groupement + agrÃ©gation + tri
- **RequÃªte**: query_tradeshows_sales_by_customer_type("collectivites")
- **Type**: AgrÃ©gation multi-nÅ“uds

---

## ğŸš€ DÃ©ploiement et Configuration

### Variables d'environnement requises (.env)

```bash
# Mistral AI
MISTRAL_API_KEY=your_key_here

# Qdrant
QDRANT_ENDPOINT=https://your-cluster.qdrant.io
QDRANT_API_KEY=your_key_here

# Neo4j
NEO4J_URI=neo4j+s://your-instance.neo4j.io
NEO4J_USERNAME=neo4j
NEO4J_PASSWORD=your_password
NEO4J_DATABASE=neo4j
```

### Commandes principales

```bash
# Installation complÃ¨te
./deploy.sh

# Initialisation manuelle
python init_system.py

# Recharger Neo4j
python neo4j_loader.py

# Tester requÃªtes Neo4j
python neo4j_query.py

# Lancer l'application
streamlit run app_hybrid.py
```

---

## ğŸ” Avantages de l'Architecture Hybride

### RAG Simple (Qdrant seul)
âœ… Rapide
âœ… Bon pour descriptions et spÃ©cifications
âœ… Pas de setup complexe
âŒ Ne comprend pas les relations
âŒ Pas d'agrÃ©gations

### RAG Hybride (Qdrant + Neo4j)
âœ… Multi-hop reasoning
âœ… AgrÃ©gations complexes (sommes, moyennes, totaux)
âœ… Comprend les relations entre entitÃ©s
âœ… RÃ©pond Ã  "Qui?", "OÃ¹?", "Combien?", "Quels Ã©vÃ©nements avec...?"
âš ï¸ Plus lent (2 requÃªtes)
âš ï¸ NÃ©cessite un graphe bien structurÃ©

### Routeur Intelligent
âœ… Choisit automatiquement la meilleure stratÃ©gie
âœ… Optimise performance (Ã©vite Neo4j si inutile)
âœ… Transparent pour l'utilisateur
âœ… Explicable (explain_routing)

---

## ğŸ› ï¸ Technologies UtilisÃ©es

| Technologie | RÃ´le |
|------------|------|
| **Streamlit** | Interface web interactive |
| **Qdrant** | Base vectorielle (embeddings) |
| **Neo4j** | Graphe de connaissances |
| **Mistral AI** | LLM + Embeddings |
| **LangChain** | Framework RAG |
| **Python 3.9+** | Langage principal |
